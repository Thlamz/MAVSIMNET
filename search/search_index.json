{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting Started About MAVSIMNET is a simulation framework for the OMNeT++ discrete event simulator based on Ardupilot's Software In The Loop (SITL) simulator. It allows you to enrich OMNeT++ and INET's simulations with realistic mobility models for the mobile nodes in your network. It works by spawning SITL instances that provide a physical simulation of the vehicle's behaviour and connecting them to the mobility classes in your simulation. A user can transparently use these mobility modules without worrying about the details of the communication and messages being exchanged between the network simulator and the SITL instances and a developer can use the strong interface provided in the project's base mobility class to implement his own mobility modules. Installation Clone the github repository. git clone https://github.com/Thlamz/MAVSIMNET/ Make sure you have INET installed in your workspace. If you see a directory named inet4.5 in your workspace you can skip this step. Note that the directory should be named inet4.5 and not something else. If the name of your inet package is different due to multiple versions make sure that you select the correct inet package in project references (Settings -> Project References -> Select correct INET version). The project required INET version 4.5. Add the project to your OMNeT++ workspace. You can do this by following the steps in File > Import... > General > Existing Projects into Workspace. The root folder should be the folder you cloned in the first step. Download the compiled SITL simulator for each vehicle type you want to use. Save the paths to these files as you will need them later. Binaries can be found on ardupilot's firmware website . These are the binaries for the most common platforms and supported vehicles: Vehicle Windows Linux Copter Link Link Plane Link Link Rover Link Link Write or download parameter files for the vehicle types you want to use. Save the paths to these files as you will need them later. We recommend donwloading the default parameter files from here: Vehicle Location Copter Link Plane Link Rover Link To verify you have completed the installation successfuly run the randomwaypoint showcase present in the showcases folder. WARNING: You will need to modify the .ini file for this simulation and any other that you run to include your SITL installation paths and parameter file paths for each type of vehicle that you want to use. You should have downloaded these files on steps 4 and 5. Further instructions can be found in the Usage section. Usage The mobility modules available in this framework are instances of INET mobility modules. If you do not know what those are or how to use them you can check INET's documentation . There you will learn how to set up a simulation environment, populate it with nodes and set them up with mobility modules . After your simulation is set up there is only a couple things you need to worry about. A very important thing to take note of is that your simulation has to use INET's Real Time Scheduler. This guarantees that the SITL instances and OMNET++ are syncronized. You can set this up in your .ini file with this line: scheduler-class = \"inet::RealTimeScheduler\" WARNING: If you are on windows and using INET version 4.2.5 or lower INET will not compile if you use inet::RealTimeScheduler with the Clang compiler. You will need to compile OMNeT++ with gcc. To do this change the value of the PREFER_CLANG parameter to \"no\". In the configure.user change the line to PREFER_CLANG=no . After doing this run these commands in mingw: make clean ./configure make Using the available mobility modules is as simple as setting your node's mobility module. You can do this with the following command, using the RandomWaypointMobility module as an example: *.client[*].mobility.typename = \"MAVLinkRandomWaypointMobility\" After placing this module in your simulation you need to set up the paths to the SITL simulators for each vehicle type supported. Currently you have to set up the copterSimulatorPath , planeSimulatorPath and roverSimulatorPath parameters. These are the paths to the files you have downloaded in step 4 of the installation, more specifically the path to the simulator binaries ( .elf file on windows and extensionless file on linux). For example, if you ara on windows and have placed the copter simulator in the CopterSimulator file of the root directory of your C: drive, the parameter should be set to: *.client.copterSimulatorPath = \"C:\\\\CopterSimulator\\\\ArduCopter.elf\" Notice the escapes characters as windows uses back-slashes in paths. INFO: If you are not using a vehicle type you can leave the path for that vehicle's simulator as an empty string. After setting this up you need to pay attention to the module's required parameters. Those can be found in the module's documentation page. Remember to pay attention if the module extends another one, as the required fields for the latter will also need to be filled. In general the parameters you need to fill when using any of the MAVSIMNET mobility models are: Parameter Type Description vehicleType int MAVLink type of vehicle that this class represents (COPTER=1, PLANE=2, ROVER=4) paramPath string Path for the parameters for this vehicle. These are the parameters you downloaded in step 5 of the installation. Do not use parameters for a different vehicle type That is all you need to know if you plan to use this framework's existing modules with no modifications. If you plan on expanding upon it of modifying the modules there are a few more things you should be aware of. Development There are two important modules in the repository's utils folder that are useful for developers. The VehicleRoutines module offers several utility functions that simplify common tasks using the MAVLink protocol. These functions generate a vector of instructions that should be queued using MAVLinkMobilityBase's queueInstructions function. The other important module is the TelemetryConditions module. As explained in the MAVLinkMobilityBase documentation messages are dispatched to the SITL instance using a message queue. This message queue moves only when the front-most message is concluded. What defines a message as concluded is a function, called a Condition, that gets called on every telemetry received. This allows a developer to define the condition that needs to be fulfilled before the next message in the queue is sent. A takeoff message could wait for the vehicle to reach a certain altutde, for example. The TelemetryRoutines module has some ready-to-use conditions for these situations.","title":"Getting Started"},{"location":"#getting-started","text":"","title":"Getting Started"},{"location":"#about","text":"MAVSIMNET is a simulation framework for the OMNeT++ discrete event simulator based on Ardupilot's Software In The Loop (SITL) simulator. It allows you to enrich OMNeT++ and INET's simulations with realistic mobility models for the mobile nodes in your network. It works by spawning SITL instances that provide a physical simulation of the vehicle's behaviour and connecting them to the mobility classes in your simulation. A user can transparently use these mobility modules without worrying about the details of the communication and messages being exchanged between the network simulator and the SITL instances and a developer can use the strong interface provided in the project's base mobility class to implement his own mobility modules.","title":"About"},{"location":"#installation","text":"Clone the github repository. git clone https://github.com/Thlamz/MAVSIMNET/ Make sure you have INET installed in your workspace. If you see a directory named inet4.5 in your workspace you can skip this step. Note that the directory should be named inet4.5 and not something else. If the name of your inet package is different due to multiple versions make sure that you select the correct inet package in project references (Settings -> Project References -> Select correct INET version). The project required INET version 4.5. Add the project to your OMNeT++ workspace. You can do this by following the steps in File > Import... > General > Existing Projects into Workspace. The root folder should be the folder you cloned in the first step. Download the compiled SITL simulator for each vehicle type you want to use. Save the paths to these files as you will need them later. Binaries can be found on ardupilot's firmware website . These are the binaries for the most common platforms and supported vehicles: Vehicle Windows Linux Copter Link Link Plane Link Link Rover Link Link Write or download parameter files for the vehicle types you want to use. Save the paths to these files as you will need them later. We recommend donwloading the default parameter files from here: Vehicle Location Copter Link Plane Link Rover Link To verify you have completed the installation successfuly run the randomwaypoint showcase present in the showcases folder. WARNING: You will need to modify the .ini file for this simulation and any other that you run to include your SITL installation paths and parameter file paths for each type of vehicle that you want to use. You should have downloaded these files on steps 4 and 5. Further instructions can be found in the Usage section.","title":"Installation"},{"location":"#usage","text":"The mobility modules available in this framework are instances of INET mobility modules. If you do not know what those are or how to use them you can check INET's documentation . There you will learn how to set up a simulation environment, populate it with nodes and set them up with mobility modules . After your simulation is set up there is only a couple things you need to worry about. A very important thing to take note of is that your simulation has to use INET's Real Time Scheduler. This guarantees that the SITL instances and OMNET++ are syncronized. You can set this up in your .ini file with this line: scheduler-class = \"inet::RealTimeScheduler\" WARNING: If you are on windows and using INET version 4.2.5 or lower INET will not compile if you use inet::RealTimeScheduler with the Clang compiler. You will need to compile OMNeT++ with gcc. To do this change the value of the PREFER_CLANG parameter to \"no\". In the configure.user change the line to PREFER_CLANG=no . After doing this run these commands in mingw: make clean ./configure make Using the available mobility modules is as simple as setting your node's mobility module. You can do this with the following command, using the RandomWaypointMobility module as an example: *.client[*].mobility.typename = \"MAVLinkRandomWaypointMobility\" After placing this module in your simulation you need to set up the paths to the SITL simulators for each vehicle type supported. Currently you have to set up the copterSimulatorPath , planeSimulatorPath and roverSimulatorPath parameters. These are the paths to the files you have downloaded in step 4 of the installation, more specifically the path to the simulator binaries ( .elf file on windows and extensionless file on linux). For example, if you ara on windows and have placed the copter simulator in the CopterSimulator file of the root directory of your C: drive, the parameter should be set to: *.client.copterSimulatorPath = \"C:\\\\CopterSimulator\\\\ArduCopter.elf\" Notice the escapes characters as windows uses back-slashes in paths. INFO: If you are not using a vehicle type you can leave the path for that vehicle's simulator as an empty string. After setting this up you need to pay attention to the module's required parameters. Those can be found in the module's documentation page. Remember to pay attention if the module extends another one, as the required fields for the latter will also need to be filled. In general the parameters you need to fill when using any of the MAVSIMNET mobility models are: Parameter Type Description vehicleType int MAVLink type of vehicle that this class represents (COPTER=1, PLANE=2, ROVER=4) paramPath string Path for the parameters for this vehicle. These are the parameters you downloaded in step 5 of the installation. Do not use parameters for a different vehicle type That is all you need to know if you plan to use this framework's existing modules with no modifications. If you plan on expanding upon it of modifying the modules there are a few more things you should be aware of.","title":"Usage"},{"location":"#development","text":"There are two important modules in the repository's utils folder that are useful for developers. The VehicleRoutines module offers several utility functions that simplify common tasks using the MAVLink protocol. These functions generate a vector of instructions that should be queued using MAVLinkMobilityBase's queueInstructions function. The other important module is the TelemetryConditions module. As explained in the MAVLinkMobilityBase documentation messages are dispatched to the SITL instance using a message queue. This message queue moves only when the front-most message is concluded. What defines a message as concluded is a function, called a Condition, that gets called on every telemetry received. This allows a developer to define the condition that needs to be fulfilled before the next message in the queue is sent. A takeoff message could wait for the vehicle to reach a certain altutde, for example. The TelemetryRoutines module has some ready-to-use conditions for these situations.","title":"Development"},{"location":"Modules/MAVLinkFileMobility/","text":"MAVLinkFileMobility Extends: MAVLinkMobilityBase Description Mobility module that reads a MAVLink waypoint mission file, in the same format produced by Mission Planner. This mission is relayed to the vehicle which follows it. Parameters Name Type Unit Default value Description waypointFile string Path to the waypoint mission file.","title":"MAVLinkFileMobility"},{"location":"Modules/MAVLinkFileMobility/#mavlinkfilemobility","text":"Extends: MAVLinkMobilityBase","title":"MAVLinkFileMobility"},{"location":"Modules/MAVLinkFileMobility/#description","text":"Mobility module that reads a MAVLink waypoint mission file, in the same format produced by Mission Planner. This mission is relayed to the vehicle which follows it.","title":"Description"},{"location":"Modules/MAVLinkFileMobility/#parameters","text":"Name Type Unit Default value Description waypointFile string Path to the waypoint mission file.","title":"Parameters"},{"location":"Modules/MAVLinkMobilityBase/","text":"MAVLinkMobilityBase Extends: MovingMobilityBase Description Base module for mobility modules that want to implement mobility using a simulated SITL instance. During the OMNeT++ simulation initialization phases this module will instantiate a SITL instance and connect to it. This module will them be responsible for receiving telemetry and sending messages to the simulated vehicle. This is a base module and should not be used directly in a simulation. It is meant to be used as a base for other modules that want to implement realistic mobility using a SITL instance. This and all child modules require the coordinateSystemModule parameter to be set. This is because a coordinate system is required to translate geographical coordinates to scene coordinates. By default the coordinateSystemModule is set to \"coordinateSystem\" so all you need to do is include a IGeographicCoordinateSystem module in your simulation. The showcase simulations are already set up with a module like this. This module works best paired with the inet::RealTimeScheduler. It will guarantee that OMNeT is syncronized with the SITL instances are syncronized with OMNeT as both simulations will run at real time. You can use this module without using the real time scheduler but the synchronicity guarantee will be off. If you want to run the simulation at aproximately real time you should set the playback time to \"1 / mobility animation speed\". If you are observing errors related to simulation time you should try removing inet::RealTimeScheduler Parameters Name Type Unit Default value Description systemId int 235 System ID of this GCS. You do not need to change this unless you are trying to connect to the SITL instance with another GCS software that uses this ID componentId int 235 Component ID of this GCS. You do not need to change this unless you are trying to connect to the SITL instance with another GCS software that uses this ID targetSystem int -1 systemId of this vehicle instance. This is a unique identifier of the simulated vehicle instance. You should take care not to repeat this ID if your simulation contains more than on MAVLinkMobility vehicle. By default will use -1, which sets the targetSystem to a unique ID. Be careful as this might conflict with other module's custom targetSystems. targetComponent int 1 componentId of this vehicle instance. Generally can be left as is. vehicleType int 1 MAVLink type of vehicle that this class represents COPTER=1 PLANE=2 ROVER=4 paramPath string Path for the parameters for this vehicle. Default parameters can be found for your vehicle type here . Be aware that incorrect parameters can prevent this vehicle from working. basePort int 5505 Base port for the SITL simulators. The actual PORT the simulators will be run is basePort + (targetSystem * 10) where targetSystem is the ID of the vehicle being simulated. If you don't want port comflicts set the same value for ALL MAVLink mobility modules and use different targetSystem for each of them. Or don't set basePort or targetSystem at all, the modules will automatically figura out ports that don't cause conflict. copterSimulatorPath string Path to the ArduCopter binary. Used to run simulator instances for this vehicle A stable version can be downloaded from: https://firmware.ardupilot.org/Tools/MissionPlanner/sitl/CopterStable/ (WINDOWS) https://firmware.ardupilot.org/Copter/stable/SITL_x86_64_linux_gnu/ (LINUX) planeSimulatorPath string Path to the ArduPlane binary. Used to run simulator instances for this vehicle A stable version can be downloaded from: https://firmware.ardupilot.org/Tools/MissionPlanner/sitl/PlaneStable/ (WINDOWS) https://firmware.ardupilot.org/Plane/stable/SITL_x86_64_linux_gnu/ (LINUX) roverSimulatorPath string // Path to the ArduRover binary. Used to run simulator instances for this vehicle A stable version can be downloaded from: https://firmware.ardupilot.org/Tools/MissionPlanner/sitl/RoverStable/ (WINDOWS) https://firmware.ardupilot.org/Rover/stable/SITL_x86_64_linux_gnu/ (LINUX) Path to the Rover binary. Used to run simulator instances for this vehicle initialLatitude double deg -35.36326015deg Latitude of the initial position of the drone. The default value is the default home of the SITL simulator initialLongitude double deg 149.16523839deg Longitude of the initial position of the drone. The default value is the default home of the SITL simulator initialAltitude double m 0m Altitude of the initial position of the drone. waitUntilReady bool false Waits until the SITL vehicle is ready to arm before the simulation is able to start. Warning : If this option is set to true it may look like the simulation has crashed on startup. This is because, to my knowledge, the only way of preventing the simulation from starting before the vehicle is ready to arm is to intetionally freeze the module's initialization. Warning : This freeze may last for several minutes, depending on how many vehicles are being initiated and your machine's hardware.","title":"MAVLinkMobilityBase"},{"location":"Modules/MAVLinkMobilityBase/#mavlinkmobilitybase","text":"Extends: MovingMobilityBase","title":"MAVLinkMobilityBase"},{"location":"Modules/MAVLinkMobilityBase/#description","text":"Base module for mobility modules that want to implement mobility using a simulated SITL instance. During the OMNeT++ simulation initialization phases this module will instantiate a SITL instance and connect to it. This module will them be responsible for receiving telemetry and sending messages to the simulated vehicle. This is a base module and should not be used directly in a simulation. It is meant to be used as a base for other modules that want to implement realistic mobility using a SITL instance. This and all child modules require the coordinateSystemModule parameter to be set. This is because a coordinate system is required to translate geographical coordinates to scene coordinates. By default the coordinateSystemModule is set to \"coordinateSystem\" so all you need to do is include a IGeographicCoordinateSystem module in your simulation. The showcase simulations are already set up with a module like this. This module works best paired with the inet::RealTimeScheduler. It will guarantee that OMNeT is syncronized with the SITL instances are syncronized with OMNeT as both simulations will run at real time. You can use this module without using the real time scheduler but the synchronicity guarantee will be off. If you want to run the simulation at aproximately real time you should set the playback time to \"1 / mobility animation speed\". If you are observing errors related to simulation time you should try removing inet::RealTimeScheduler","title":"Description"},{"location":"Modules/MAVLinkMobilityBase/#parameters","text":"Name Type Unit Default value Description systemId int 235 System ID of this GCS. You do not need to change this unless you are trying to connect to the SITL instance with another GCS software that uses this ID componentId int 235 Component ID of this GCS. You do not need to change this unless you are trying to connect to the SITL instance with another GCS software that uses this ID targetSystem int -1 systemId of this vehicle instance. This is a unique identifier of the simulated vehicle instance. You should take care not to repeat this ID if your simulation contains more than on MAVLinkMobility vehicle. By default will use -1, which sets the targetSystem to a unique ID. Be careful as this might conflict with other module's custom targetSystems. targetComponent int 1 componentId of this vehicle instance. Generally can be left as is. vehicleType int 1 MAVLink type of vehicle that this class represents COPTER=1 PLANE=2 ROVER=4 paramPath string Path for the parameters for this vehicle. Default parameters can be found for your vehicle type here . Be aware that incorrect parameters can prevent this vehicle from working. basePort int 5505 Base port for the SITL simulators. The actual PORT the simulators will be run is basePort + (targetSystem * 10) where targetSystem is the ID of the vehicle being simulated. If you don't want port comflicts set the same value for ALL MAVLink mobility modules and use different targetSystem for each of them. Or don't set basePort or targetSystem at all, the modules will automatically figura out ports that don't cause conflict. copterSimulatorPath string Path to the ArduCopter binary. Used to run simulator instances for this vehicle A stable version can be downloaded from: https://firmware.ardupilot.org/Tools/MissionPlanner/sitl/CopterStable/ (WINDOWS) https://firmware.ardupilot.org/Copter/stable/SITL_x86_64_linux_gnu/ (LINUX) planeSimulatorPath string Path to the ArduPlane binary. Used to run simulator instances for this vehicle A stable version can be downloaded from: https://firmware.ardupilot.org/Tools/MissionPlanner/sitl/PlaneStable/ (WINDOWS) https://firmware.ardupilot.org/Plane/stable/SITL_x86_64_linux_gnu/ (LINUX) roverSimulatorPath string // Path to the ArduRover binary. Used to run simulator instances for this vehicle A stable version can be downloaded from: https://firmware.ardupilot.org/Tools/MissionPlanner/sitl/RoverStable/ (WINDOWS) https://firmware.ardupilot.org/Rover/stable/SITL_x86_64_linux_gnu/ (LINUX) Path to the Rover binary. Used to run simulator instances for this vehicle initialLatitude double deg -35.36326015deg Latitude of the initial position of the drone. The default value is the default home of the SITL simulator initialLongitude double deg 149.16523839deg Longitude of the initial position of the drone. The default value is the default home of the SITL simulator initialAltitude double m 0m Altitude of the initial position of the drone. waitUntilReady bool false Waits until the SITL vehicle is ready to arm before the simulation is able to start. Warning : If this option is set to true it may look like the simulation has crashed on startup. This is because, to my knowledge, the only way of preventing the simulation from starting before the vehicle is ready to arm is to intetionally freeze the module's initialization. Warning : This freeze may last for several minutes, depending on how many vehicles are being initiated and your machine's hardware.","title":"Parameters"},{"location":"Modules/MAVLinkRandomWaypointMobility/","text":"MAVLinkRandomWaypointMobility Extends: MAVLinkMobilityBase Description This module is analogous to INET's RandomWaypointMobility. The vehicle will follow random waypoints within the environment constraints and wait there for a set amount before traveling to the next one. Parameters Name Type Unit Default value Description speed double mps 20mps Speed at which the vehicle should travel waitTime double s 0s Time the vehicle will wait before traveling to the next waypoint waypointRadius double m 30m Radius of the waypoint. Vehicles within this radius will be considered to have reached the waypoint","title":"MAVLinkRandomWaypointMobility"},{"location":"Modules/MAVLinkRandomWaypointMobility/#mavlinkrandomwaypointmobility","text":"Extends: MAVLinkMobilityBase","title":"MAVLinkRandomWaypointMobility"},{"location":"Modules/MAVLinkRandomWaypointMobility/#description","text":"This module is analogous to INET's RandomWaypointMobility. The vehicle will follow random waypoints within the environment constraints and wait there for a set amount before traveling to the next one.","title":"Description"},{"location":"Modules/MAVLinkRandomWaypointMobility/#parameters","text":"Name Type Unit Default value Description speed double mps 20mps Speed at which the vehicle should travel waitTime double s 0s Time the vehicle will wait before traveling to the next waypoint waypointRadius double m 30m Radius of the waypoint. Vehicles within this radius will be considered to have reached the waypoint","title":"Parameters"},{"location":"Utils/TelemetryConditions/","text":"TelemetryConditions Description This module contains utility functions used as or to generate Condition functions. Conditions are functions used by MAVLinkMobilityBase to check if a MAVLink message is concluded and a new one should be sent to the simulator. They work by receiving incoming telemetry on their mavlink_message_t parameter and returning a boolean to flag if that telemetry completes the condition. Functions checkEmpty bool checkEmpty(mavlink_message_t); An empty condition getCheckCmdAck std::function<bool(mavlink_message_t)> getCheckCmdAck(uint8_t systemId, uint8_t componentId, unsigned short command, uint8_t senderSystemId); Get a condition that waits for a specific command acknowledge message. getCheckPreArm std::function<bool(mavlink_message_t)> getCheckPreArm(uint8_t senderSystemId); Get a condition that checks if the vehicles pre-arm is good getCheckArm std::function<bool(mavlink_message_t)> getCheckArm(uint8_t senderSystemId); Get a condition that checks if the vehicle is armed getCheckAltitude std::function<bool(mavlink_message_t)> getCheckAltitude(int32_t altitude, int32_t tolerance, uint8_t senderSystemId); Get a condition that checks if the vehicle has reached a specific altitude within a tolerance getCheckMissionRequest std::function<bool(mavlink_message_t)> getCheckMissionRequest(uint8_t systemid, uint8_t componentId, uint16_t sequenceNumber, uint8_t senderSystemId); Get a condition that waits for a mission request message with a specific sequence number getCheckMissionAck std::function<bool(mavlink_message_t)> getCheckMissionAck(uint8_t systemId, uint8_t componentId, uint8_t senderSystemId); Get a condition that waits for a mission ack message getCheckMissionItemReached std::function<bool(mavlink_message_t)> getCheckMissionItemReached(uint16_t seq, uint8_t senderSystemId); Get a condition that waits for a mission item reached message getCheckTargetGlobal std::function<bool(mavlink_message_t)> getCheckTargetGlobal(float lat, float lon, float alt, uint8_t senderSystemId); Get a condition that waits for a target global message with a specific location getCheckGlobalPosition std::function<bool(mavlink_message_t)> getCheckGlobalPosition(float lat, float lon, float alt, float tolerance, inet::IGeographicCoordinateSystem *coordinateSystem, uint8_t senderSystemId); Get a condition that checks if the vehicle has reached a specific condition within tolerance getCheckParamValue std::function<bool(mavlink_message_t)> getCheckParamValue(std::string param_id, float param_value, uint8_t senderSystemId); Get a condition that checks if a specific parameter has a desired value getCheckMode std::function<bool(mavlink_message_t)> getCheckMode(Mode mode, VehicleType type, uint8_t senderSystemId); Get a condition that checks if the vehicle is on a specific mode","title":"TelemetryConditions"},{"location":"Utils/TelemetryConditions/#telemetryconditions","text":"","title":"TelemetryConditions"},{"location":"Utils/TelemetryConditions/#description","text":"This module contains utility functions used as or to generate Condition functions. Conditions are functions used by MAVLinkMobilityBase to check if a MAVLink message is concluded and a new one should be sent to the simulator. They work by receiving incoming telemetry on their mavlink_message_t parameter and returning a boolean to flag if that telemetry completes the condition.","title":"Description"},{"location":"Utils/TelemetryConditions/#functions","text":"","title":"Functions"},{"location":"Utils/TelemetryConditions/#checkempty","text":"bool checkEmpty(mavlink_message_t); An empty condition","title":"checkEmpty"},{"location":"Utils/TelemetryConditions/#getcheckcmdack","text":"std::function<bool(mavlink_message_t)> getCheckCmdAck(uint8_t systemId, uint8_t componentId, unsigned short command, uint8_t senderSystemId); Get a condition that waits for a specific command acknowledge message.","title":"getCheckCmdAck"},{"location":"Utils/TelemetryConditions/#getcheckprearm","text":"std::function<bool(mavlink_message_t)> getCheckPreArm(uint8_t senderSystemId); Get a condition that checks if the vehicles pre-arm is good","title":"getCheckPreArm"},{"location":"Utils/TelemetryConditions/#getcheckarm","text":"std::function<bool(mavlink_message_t)> getCheckArm(uint8_t senderSystemId); Get a condition that checks if the vehicle is armed","title":"getCheckArm"},{"location":"Utils/TelemetryConditions/#getcheckaltitude","text":"std::function<bool(mavlink_message_t)> getCheckAltitude(int32_t altitude, int32_t tolerance, uint8_t senderSystemId); Get a condition that checks if the vehicle has reached a specific altitude within a tolerance","title":"getCheckAltitude"},{"location":"Utils/TelemetryConditions/#getcheckmissionrequest","text":"std::function<bool(mavlink_message_t)> getCheckMissionRequest(uint8_t systemid, uint8_t componentId, uint16_t sequenceNumber, uint8_t senderSystemId); Get a condition that waits for a mission request message with a specific sequence number","title":"getCheckMissionRequest"},{"location":"Utils/TelemetryConditions/#getcheckmissionack","text":"std::function<bool(mavlink_message_t)> getCheckMissionAck(uint8_t systemId, uint8_t componentId, uint8_t senderSystemId); Get a condition that waits for a mission ack message","title":"getCheckMissionAck"},{"location":"Utils/TelemetryConditions/#getcheckmissionitemreached","text":"std::function<bool(mavlink_message_t)> getCheckMissionItemReached(uint16_t seq, uint8_t senderSystemId); Get a condition that waits for a mission item reached message","title":"getCheckMissionItemReached"},{"location":"Utils/TelemetryConditions/#getchecktargetglobal","text":"std::function<bool(mavlink_message_t)> getCheckTargetGlobal(float lat, float lon, float alt, uint8_t senderSystemId); Get a condition that waits for a target global message with a specific location","title":"getCheckTargetGlobal"},{"location":"Utils/TelemetryConditions/#getcheckglobalposition","text":"std::function<bool(mavlink_message_t)> getCheckGlobalPosition(float lat, float lon, float alt, float tolerance, inet::IGeographicCoordinateSystem *coordinateSystem, uint8_t senderSystemId); Get a condition that checks if the vehicle has reached a specific condition within tolerance","title":"getCheckGlobalPosition"},{"location":"Utils/TelemetryConditions/#getcheckparamvalue","text":"std::function<bool(mavlink_message_t)> getCheckParamValue(std::string param_id, float param_value, uint8_t senderSystemId); Get a condition that checks if a specific parameter has a desired value","title":"getCheckParamValue"},{"location":"Utils/TelemetryConditions/#getcheckmode","text":"std::function<bool(mavlink_message_t)> getCheckMode(Mode mode, VehicleType type, uint8_t senderSystemId); Get a condition that checks if the vehicle is on a specific mode","title":"getCheckMode"},{"location":"Utils/VehicleRoutines/","text":"VehicleRoutines Description This module provides several utility functions that facilitate the communication with the SITL instance. Each function generates a vector of instructions that command the simulated vehicle to perform a common task. This vector of instructions can be read by MAVLinkMobilityBase with the queueInstructions() method. Functions armTakeoff std::vector<std::shared_ptr<Instruction>> armTakeoff(uint8_t senderSystem, uint8_t senderComponent, VehicleType type, float altitude, uint8_t targetSystem, uint8_t targetComponent, omnetpp::simtime_t timeout=60, int retries=3); Instructs the vehicle to ARM and TAKEOFF setMode std::vector<std::shared_ptr<Instruction>> setMode(uint8_t senderSystem, uint8_t senderComponent, VehicleType type, Mode mode, uint8_t targetSystem, uint8_t targetComponent, omnetpp::simtime_t timeout=60, int retries=3); Instructs the vehicle to set a specific Mode","title":"VehicleRoutines"},{"location":"Utils/VehicleRoutines/#vehicleroutines","text":"","title":"VehicleRoutines"},{"location":"Utils/VehicleRoutines/#description","text":"This module provides several utility functions that facilitate the communication with the SITL instance. Each function generates a vector of instructions that command the simulated vehicle to perform a common task. This vector of instructions can be read by MAVLinkMobilityBase with the queueInstructions() method.","title":"Description"},{"location":"Utils/VehicleRoutines/#functions","text":"","title":"Functions"},{"location":"Utils/VehicleRoutines/#armtakeoff","text":"std::vector<std::shared_ptr<Instruction>> armTakeoff(uint8_t senderSystem, uint8_t senderComponent, VehicleType type, float altitude, uint8_t targetSystem, uint8_t targetComponent, omnetpp::simtime_t timeout=60, int retries=3); Instructs the vehicle to ARM and TAKEOFF","title":"armTakeoff"},{"location":"Utils/VehicleRoutines/#setmode","text":"std::vector<std::shared_ptr<Instruction>> setMode(uint8_t senderSystem, uint8_t senderComponent, VehicleType type, Mode mode, uint8_t targetSystem, uint8_t targetComponent, omnetpp::simtime_t timeout=60, int retries=3); Instructs the vehicle to set a specific Mode","title":"setMode"}]}